#include "SuperEnum.h"
#include <memory>

using namespace SuperEnumGenerator;
using namespace FatedQuestLibraries;

SuperEnum::SuperEnum()
{
}

bool SuperEnum::FromString(const std::string& superEnumFile)
{
    std::shared_ptr<StoredDocument> xml = std::make_shared<RapidXMLDocument>();
    if (!xml->Load(superEnumFile))
    {
        // Could not parse.
        return false;
    }

    std::shared_ptr<StoredDocumentNode> root = xml->GetRoot();
    if (!ParseRoot(root))
    {
        return false;
    }
    for (std::shared_ptr<StoredDocumentNode> child = root->GetFirstChild(); child; child = child->GetAdjacentNode())
    {
        std::string name = StringHelpers::Trim(StringHelpers::ToLower(child->Name()));
        if (name == "header")
        {
            if (!ParseHeader(child))
            {
                return false;
            }
        }
        else if (name == "namespace")
        {
            if (!ParseNamespace(child))
            {
                return false;
            }
        }
        else if (name == "enumcomment")
        {
            if (!ParseEnumComment(child))
            {
                return false;
            }
        }
        else if (name == "enumname")
        {
            if (!ParseEnumName(child))
            {
                return false;
            }
        }
    }


    return true;
}

std::string SuperEnum::ToString()
{
    std::string output = "";
    int indents = 0;

    output += PrintHeader(indents);
    output += "// +------------------------------+\n";
    output += "// Generated by SuperGenerator as an\n";
    output += "// SuperEnum. See Tools for details.\n";
    output += "// +------------------------------+\n";

    if (m_namespace.Parsed)
    {
        output += "namespace " + m_namespace.Value + "\n";
        output += "{\n";
        ++indents;
    }

    output += PrintEnum(indents);

    if (m_enumType == SuperEnumType::BitFlag)
    {
        output += "\n";
        output += PrintFlagMethods(indents);
    }

    output += "\n";
    output += PrintEnumHelper(indents);


    if (m_namespace.Parsed)
    {
        --indents;
        output += "}\n";
    }
    return output;
}

bool SuperEnum::ParseRoot(std::shared_ptr<StoredDocumentNode> rootNode)
{
    m_enumType = SuperEnumType::Standard;
    if (auto typeAttribute = rootNode->Attribute("Type", CaseSensitivity::IgnoreCase))
    {
        SuperEnumType parsed = ESuperEnumType::FromString(typeAttribute->Value());
        if (parsed != SuperEnumType::Unknown)
        {
            m_enumType = parsed;
        }
    }

    return true;
}

bool SuperEnum::ParseHeader(std::shared_ptr<StoredDocumentNode> headerNode)
{
    std::string header = StringHelpers::Trim(headerNode->Inner());
    if (header == "")
    {
        return false;
    }

    m_header.Parsed = true;
    m_header.Value = header;

    return true;
}

bool SuperEnum::ParseNamespace(std::shared_ptr<StoredDocumentNode> namespaceNode)
{
    for (std::shared_ptr<StoredDocumentAttribute> attribute : namespaceNode->Attributes())
    {
        if (StringHelpers::ToLower(attribute->Name()) == "name")
        {
            std::string value = StringHelpers::Trim(attribute->Value());
            if (value != "")
            {
                m_namespace.Parsed = true;
                m_namespace.Value = value;
            }
        }
    }


    return m_namespace.Parsed;
}

bool SuperEnum::ParseEnumComment(std::shared_ptr<StoredDocumentNode> enumNode)
{
    std::string comment = StringHelpers::Trim(enumNode->Inner());
    if (comment == "")
    {
        return false;
    }

    m_enumComment.Parsed = true;
    m_enumComment.Value = comment;

    return true;
}

bool SuperEnum::ParseEnumName(std::shared_ptr<StoredDocumentNode> enumNode)
{
    for (std::shared_ptr<StoredDocumentAttribute> attribute : enumNode->Attributes())
    {
        std::string name = StringHelpers::ToLower(attribute->Name());
        if (name == "name")
        {
            std::string value = StringHelpers::Trim(attribute->Value());
            if (value != "")
            {
                m_enumName.Parsed = true;
                m_enumName.Value = value;
            }
        }
    }

    for (std::shared_ptr<StoredDocumentNode> child = enumNode->GetFirstChild(); child; child = child->GetAdjacentNode())
    {
        std::shared_ptr<EnumValueString> enumValue = std::make_shared<EnumValueString>();
        
        enumValue->Value = child->Name();
        enumValue->LowercaseValue = StringHelpers::ToLower(child->Name());
        enumValue->Comment = child->Inner();

        bool parsedAttributes = true;
        for (std::shared_ptr<StoredDocumentAttribute> attribute : child->Attributes())
        {
            std::string name = StringHelpers::ToLower(attribute->Name());
            if (name == "value")
            {
                std::string value = StringHelpers::Trim(attribute->Value());
                if (value != "")
                {
                    int outValue = 0;
                    if (IntHelpers::TryParse(attribute->Value(), outValue))
                    {
                        enumValue->SetValue = outValue;
                        enumValue->ValueIsSet = true;
                    }
                    else
                    {
                        // Could not read number.
                        // TODO: Add Log for this.
                        parsedAttributes = false;
                        break;
                    }
                }
            }
            else if (name == "hidefromlists")
            {
                std::string value = StringHelpers::ToLower(StringHelpers::Trim(attribute->Value()));
                if (value != "")
                {
                    if (value == "true" || value == "t")
                    {
                        enumValue->HideFromLists = true;
                    }
                    else
                    {
                        enumValue->HideFromLists = false;
                    }
                }
            }
            else if (name == "isunknownvalue")
            {
                std::string value = StringHelpers::ToLower(StringHelpers::Trim(attribute->Value()));
                if (value != "")
                {
                    if (value == "true" || value == "t")
                    {
                        enumValue->IsUnknownValue = true;
                    }
                    else
                    {
                        enumValue->IsUnknownValue = false;
                    }
                }
            }
        }

        m_enumValues.push_back(enumValue);
    }

    SetUpImpliedEnumValues();

    return m_enumName.Parsed && m_enumValues.size() > 0;
}

bool SuperEnum::SetUpImpliedEnumValues()
{
    int currentIndex = 0;
    for (int i = 0; i < m_enumValues.size(); ++i)
    {
        if (m_enumValues[i]->ValueIsSet)
        {
            m_enumValues[i]->ImpliedValue = m_enumValues[i]->SetValue;
            currentIndex = m_enumValues[i]->SetValue + 1;
        }
        else
        {
            m_enumValues[i]->ImpliedValue = currentIndex++;
        }
    }

    return true;
}

std::string SuperEnum::PrintDateTime()
{
    std::time_t currentTime = std::time(nullptr);
    std::tm localTime;

    if (localtime_s(&localTime, &currentTime) != 0) {
        std::cerr << "Error getting local time!" << std::endl;
        return "";
    }

    std::stringstream outputStream;
    outputStream << (localTime.tm_year + 1900);
    outputStream << "/" << (localTime.tm_mon + 1);
    outputStream << "/" << localTime.tm_mday;
    outputStream << " " << localTime.tm_hour;
    outputStream << ":" << localTime.tm_min;
    outputStream << ":" << localTime.tm_sec;

    return outputStream.str();
}

std::string SuperEnum::PrintIndents(int number)
{
    std::string output = "";
    for (int i = 0; i < number; ++i)
    {
        output += "    ";
    }

    return output;
}

std::string SuperEnumGenerator::SuperEnum::PrintHeader(int indents)
{
    std::string output = "";
    if (!m_header.Parsed)
    {
        return output;
    }

    std::vector<std::string> lines = StringHelpers::Split(m_header.Value, "\n");
    for (const std::string line : lines)
    {
        std::string lineTrimmed = StringHelpers::Trim(line);
        if (lineTrimmed != "")
        {
            output += PrintIndents(indents) + lineTrimmed + "\n";
        }
    }

    // These are used by this script
    output += PrintIndents(indents) + "#include <vector>\n";
    output += PrintIndents(indents) + "#include <string>\n";

    output += PrintIndents(indents) + "\n";
    output += PrintIndents(indents) + "\n";

    return output;
}

std::string SuperEnum::PrintEnum(int indents)
{
    std::string output;
    if (m_enumComment.Parsed)
    {
        output += PrintSingleComment(m_enumComment.Value, indents);
    }

    if (m_enumName.Parsed)
    {
        output += PrintIndents(indents) + "enum class " + m_enumName.Value;
        output += " : " + FigureOutType();
        output += "\n";

        output += PrintIndents(indents) + "{\n";
        ++indents;
    }

    int currentBitFlag = -1;
    for (int i = 0; i < m_enumValues.size(); ++i)
    {
        const std::shared_ptr<EnumValueString>& enumValue = m_enumValues[i];
        std::string comments = PrintSingleComment(enumValue->Comment, indents);
        if (comments != "")
        {
            output += comments;
        }

        // Print the actual name within the enum class
        output += PrintIndents(indents) + enumValue->Value;
        if (enumValue->ValueIsSet)
        {
            output += " = " + std::to_string(enumValue->SetValue);
            enumValue->FlagValue = enumValue->SetValue;
        }
        else if (m_enumType == SuperEnumType::BitFlag)
        {
            if (currentBitFlag == -1)
            {
                output += " = 0";
                enumValue->FlagValue = 0;
            }
            else
            {
                output += " = 1 << " + std::to_string(currentBitFlag);
                enumValue->FlagValue = 1 + currentBitFlag;
            }

            ++currentBitFlag;
        }

        output += ",\n";

        // Ensure there is a line space between each other than the very last.
        if (i + 1 < m_enumValues.size())
        {
            output += "\n";
        }
    }

    if (m_namespace.Parsed)
    {
        --indents;
        output += PrintIndents(indents) + "};\n";
    }

    return output;
}

std::string SuperEnum::PrintEnumHelper(int indents)
{
    std::string output = "";
    if (!m_enumName.Parsed)
    {
        return std::string();
    }

    output += PrintSingleComment("Accompanies enums to provide extra functionality.", indents);
    output += PrintIndents(indents) + "class E" + m_enumName.Value + "\n";
    output += PrintIndents(indents) + "{\n";
    output += PrintIndents(indents) + "public:\n";

    ++indents;
    output += PrintIndents(indents) + "static " + m_enumName.Value + " Min() { return " + m_enumName.Value + "::" + GetMinEnumValue() + "; }\n";
    output += PrintIndents(indents) + "static " + m_enumName.Value + " Max() { return " + m_enumName.Value + "::" + GetMaxEnumValue() + "; }\n";
    output += PrintToArray(indents);
    output += PrintToVector(indents);
    output += PrintToString(indents);
    output += PrintFromString(indents);

    if (m_enumType == SuperEnumType::BitFlag)
    {
        output += PrintFlagHelperMethods(indents);
    }

    --indents;

    output += PrintIndents(indents) + "};\n";

    return output;
}

std::string SuperEnum::PrintToArray(int indents)
{
    if (!m_enumName.Parsed)
    {
        return std::string();
    }

    std::string output = "";

    output += "\n";
    output += PrintIndents(indents) + "static " + m_enumName.Value + "* ToArray()\n";
    output += PrintIndents(indents) + "{\n";
        ++indents;
        output += PrintIndents(indents) + "static " + m_enumName.Value + " returnArray[] =\n";
        output += PrintIndents(indents) + "{\n";
            ++indents;
            for (const std::shared_ptr<EnumValueString>& enumValue : m_enumValues)
            {
                if (enumValue->HideFromLists)
                {
                    continue;
                }

                output += PrintIndents(indents) + m_enumName.Value + "::" + enumValue->Value + ",\n";

            }
            --indents;
            output += PrintIndents(indents) + "};\n";
            output += PrintIndents(indents) + "\n";
            output += PrintIndents(indents) + "return returnArray;\n";
        --indents;
    output += PrintIndents(indents) + "}\n";
    return output;
}

std::string SuperEnum::PrintToVector(int indents)
{
    if (!m_enumName.Parsed)
    {
        return std::string();
    }

    std::string output = "";

    output += "\n";
    output += PrintIndents(indents) + "static std::vector<" + m_enumName.Value + "> ToVector()\n";
    output += PrintIndents(indents) + "{\n";
    ++indents;
        output += PrintIndents(indents) + "static std::vector<" + m_enumName.Value + "> returnVector =\n";
        output += PrintIndents(indents) + "{\n";
        ++indents;
            for (const std::shared_ptr<EnumValueString>& enumValue : m_enumValues)
            {
                if (enumValue->HideFromLists)
                {
                    continue;
                }

                output += PrintIndents(indents) + m_enumName.Value + "::" + enumValue->Value + ",\n";

            }
        --indents;
        output += PrintIndents(indents) + "};\n";
        output += PrintIndents(indents) + "\n";
        output += PrintIndents(indents) + "return returnVector;\n";
    --indents;
    output += PrintIndents(indents) + "}\n";
    return output;
}

std::string SuperEnum::PrintToString(int indents)
{
    if (!m_enumName.Parsed)
    {
        return std::string();
    }

    std::string output = "";

    output += "\n";
    output += PrintIndents(indents) + "static std::string ToString(" + m_enumName.Value + " value)\n";
    output += PrintIndents(indents) + "{\n";
    ++indents;
        output += PrintIndents(indents) + "switch (value)\n";
        output += PrintIndents(indents) + "{\n";
        ++indents;
            for (const std::shared_ptr<EnumValueString>& enumValue : m_enumValues)
            {
                output += PrintIndents(indents) + "case " + m_enumName.Value + "::" + enumValue->Value;
                output += ": return \"" + enumValue->Value + "\";\n";

            }
        --indents;
        output += PrintIndents(indents) + "}\n";
        output += PrintIndents(indents) + "\n";
        output += PrintIndents(indents) + "return \""+ GetUnknownValue() + "\";\n";
    --indents;
    output += PrintIndents(indents) + "}\n";
    return output;
}

std::string SuperEnum::PrintFromString(int indents)
{
    if (!m_enumName.Parsed)
    {
        return std::string();
    }

    std::string output = "";

    output += "\n";
    output += PrintIndents(indents) + "static " + m_enumName.Value + " FromString(std::string value, bool checkCase = true)\n";
    output += PrintIndents(indents) + "{\n";
    ++indents;
        output += PrintIndents(indents) + "if (checkCase)\n";
        output += PrintIndents(indents) + "{\n";
        ++indents;
        for (const std::shared_ptr<EnumValueString>& enumValue : m_enumValues)
        {
            output += PrintIndents(indents) + "if (value == \"" + enumValue->Value + "\") return " + m_enumName.Value + "::" + enumValue->Value + ";\n";
        }
        --indents;
        output += PrintIndents(indents) + "}\n";
        output += PrintIndents(indents) + "else\n";
        output += PrintIndents(indents) + "{\n";
        ++indents;
        output += PrintIndents(indents) + "std::string valueLower = ToLower(value); \n";
        for (const std::shared_ptr<EnumValueString>& enumValue : m_enumValues)
        {
            
            output += PrintIndents(indents) + "if (valueLower == \"" + enumValue->LowercaseValue + "\") return " + m_enumName.Value + "::" + enumValue->Value + ";\n";
        }
        --indents;
        output += PrintIndents(indents) + "}\n";
        output += PrintIndents(indents) + "\n";
        output += PrintIndents(indents) + "return " + m_enumName.Value + "::" + GetUnknownValue() + ";\n";
    --indents;
    output += PrintIndents(indents) + "}\n";

    output += "\n";

    // To Lower method
    output += PrintIndents(indents) + "/// <summary>\n";
    output += PrintIndents(indents) + "/// Converts to lower. Copy from StringHelpers to ensure Enum does not require\n";
    output += PrintIndents(indents) + "/// any outside dependency. Although we could include a header, doing so restricts\n";
    output += PrintIndents(indents) + "/// the project which holds StringHelpers.\n";
    output += PrintIndents(indents) + "/// </summary>\n";
    output += PrintIndents(indents) + "static std::string ToLower(const std::string & input)\n";
    output += PrintIndents(indents) + "{\n";
    ++indents;
        output += PrintIndents(indents) + "std::string output = input;\n";
        output += PrintIndents(indents) + "for (char& c : output)\n";
        output += PrintIndents(indents) + "{\n";
        ++indents;
            output += PrintIndents(indents) + "if (c >= 'A' && c <= 'Z')\n";
            output += PrintIndents(indents) + "{\n";
            ++indents;
                output += PrintIndents(indents) + "c = c - 'A' + 'a';\n";
            --indents;
            output += PrintIndents(indents) + "}\n";
        --indents;
        output += PrintIndents(indents) + "}\n";
        output += PrintIndents(indents) + "return output;\n";
    --indents;
    output += PrintIndents(indents) + "}\n";

    return output;
}

std::string SuperEnum::GetMinEnumValue()
{
    bool foundMin = false;
    int currentIndex = 0;
    std::string min = "";
    for (const std::shared_ptr<EnumValueString>& enumValue : m_enumValues)
    {
        if (enumValue->HideFromLists)
        {
            // Min and Max count as lists.
            continue;
        }

        if (!foundMin || enumValue->ImpliedValue < currentIndex)
        {
            currentIndex = enumValue->ImpliedValue;
            min = enumValue->Value;
            foundMin = true;
        }
    }

    return min;
}

std::string SuperEnum::GetMaxEnumValue()
{
    bool foundMin = false;
    int currentIndex = 0;
    std::string max = "";
    for (const std::shared_ptr<EnumValueString>& enumValue : m_enumValues)
    {
        if (enumValue->HideFromLists)
        {
            // Min and Max count as lists.
            continue;
        }

        if (!foundMin || enumValue->ImpliedValue > currentIndex)
        {
            currentIndex = enumValue->ImpliedValue;
            max = enumValue->Value;
            foundMin = true;
        }
    }

    return max;
}

std::string SuperEnum::GetUnknownValue()
{
    bool foundValue = false;
    std::string unknown = "";
    for (const std::shared_ptr<EnumValueString>& enumValue : m_enumValues)
    {
        if (!foundValue)
        {
            unknown = enumValue->Value;
            foundValue = true;
        }

        if (enumValue->IsUnknownValue)
        {
            unknown = enumValue->Value;
            break;
        }
    }

    return unknown;
}

std::string SuperEnum::PrintSingleComment(const std::string& rawComment, int indents)
{
    std::string output = {};
    if (rawComment.empty())
    {
        return output;
    }

    output += PrintIndents(indents) + "/// <summary>\n";
    std::vector<std::string> lines = StringHelpers::Split(rawComment, "\n");
    for (const std::string line : lines)
    {
        std::string lineTrimmed = StringHelpers::Trim(line);
        if (lineTrimmed != "")
        {
            output += PrintIndents(indents) + "/// " + lineTrimmed + "\n";
        }
    }
    output += PrintIndents(indents) + "/// </summary>\n";

    return output;
}

std::string SuperEnum::PrintFlagMethods(int indents)
{
    std::string output = {};
    output += PrintIndents(indents) + "inline " + m_enumName.Value + " operator | (KeyState lhs, KeyState rhs)\n";
    output += PrintIndents(indents) + "{\n";
    ++indents;
        output += PrintIndents(indents) + "using T = std::underlying_type_t <" + m_enumName.Value  + ">;\n";
        output += PrintIndents(indents) + "return static_cast<" + m_enumName.Value  + ">(static_cast<T>(lhs) | static_cast<T>(rhs));\n";
    --indents;
    output += PrintIndents(indents) + "}\n";
    output += "\n";

    output += PrintIndents(indents) + "inline " + m_enumName.Value + "& operator |= (" + m_enumName.Value + "& lhs, " + m_enumName.Value + " rhs)\n";
    output += PrintIndents(indents) + "{\n";
    ++indents;
        output += PrintIndents(indents) + "lhs = lhs | rhs;\n";
        output += PrintIndents(indents) + "return lhs;\n";
    --indents;
    output += PrintIndents(indents) + "}\n";
    output += "\n";

    output += PrintIndents(indents) + "inline " + m_enumName.Value + " operator & (" + m_enumName.Value + " lhs, " + m_enumName.Value + " rhs)\n";
    output += PrintIndents(indents) + "{\n";
    ++indents;
    output += PrintIndents(indents) + "using T = std::underlying_type_t <" + m_enumName.Value + ">;\n";
    output += PrintIndents(indents) + "return static_cast<" + m_enumName.Value + ">(static_cast<T>(lhs) & static_cast<T>(rhs));\n";
    --indents;
    output += PrintIndents(indents) + "}\n";
    output += "\n";

    output += PrintIndents(indents) + "inline " + m_enumName.Value + "& operator &= (" + m_enumName.Value + "& lhs, " + m_enumName.Value + " rhs)\n";
    output += PrintIndents(indents) + "{\n";
    ++indents;
    output += PrintIndents(indents) + "lhs = lhs | rhs;\n";
    output += PrintIndents(indents) + "return lhs;\n";
    --indents;
    output += PrintIndents(indents) + "}\n";

    return output;
}

std::string SuperEnum::PrintFlagHelperMethods(int indents)
{
    std::string output = {};

    // To compare the value we need the 0 value.
    // If we cannot find it, we will get the lowest.
    // This could be hidden.
    std::shared_ptr<EnumValueString> closestToZero;
    for (const std::shared_ptr<EnumValueString>& enumValue : m_enumValues)
    {
        if (!closestToZero)
        {
            closestToZero = enumValue;
        }

        if (enumValue->FlagValue == 0)
        {
            closestToZero = enumValue;
            break;
        }

        if (enumValue->FlagValue < closestToZero->FlagValue && enumValue->FlagValue > 0)
        {
            closestToZero = enumValue;
        }
    }

    output += "\n";
    output += PrintIndents(indents) + "/// <summary>\n";
    output += PrintIndents(indents) + "/// Test to see whether value has the given flag.\n";
    output += PrintIndents(indents) + "/// </summary>\n";
    output += PrintIndents(indents) + "/// <param name=\"origin\">Origin to look for flag in. </param>\n";
    output += PrintIndents(indents) + "/// <param name=\"lookFor\">Value to look for. </param>\n";
    output += PrintIndents(indents) + "/// <returns>True means has flag. </returns>\n";
    output += PrintIndents(indents) + "static bool HasFlag(" + m_enumName.Value + " origin, " + m_enumName.Value + " lookFor)\n";
    output += PrintIndents(indents) + "{\n";
    ++indents;
        output += PrintIndents(indents) + "return (origin & lookFor) != " + m_enumName.Value + "::" + closestToZero->Value + ";\n";
    --indents;
    output += PrintIndents(indents) + "}\n";

    return output;
}

std::string SuperEnum::FigureOutType()
{
    int min = GetMinEnumNumberValue();
    int max = GetMaxEnumNumberValue();

    std::string type = {};
    if (min >= 0)
    {
        if (max <= 255)
        {
            type = "uint8_t";
        }
        else if(max <= 65535)
        {
            type = "uint16_t";
        }
        else if (max <= 65535)
        {
            type = "uint16_t";
        }
        else
        {
            type = "uint32_t";
        }
    }
    else
    {
        if (min >= -128 && max <= 127)
        {
            type = "int8_t";
        }
        else if (min >= -32768 && max <= 32767)
        {
            type = "int16_t";
        }
        else
        {
            type = "int32_t";
        }
    }

    return type;
}

int SuperEnum::GetMinEnumNumberValue()
{
    bool foundMin = false;
    int currentIndex = 0;
    for (const std::shared_ptr<EnumValueString>& enumValue : m_enumValues)
    {
        if (!foundMin || enumValue->ImpliedValue < currentIndex)
        {
            currentIndex = enumValue->ImpliedValue;
            foundMin = true;
        }
    }

    return currentIndex;
}

int SuperEnum::GetMaxEnumNumberValue()
{
    bool foundMin = false;
    int currentIndex = 0;
    for (const std::shared_ptr<EnumValueString>& enumValue : m_enumValues)
    {
        if (!foundMin || enumValue->ImpliedValue > currentIndex)
        {
            currentIndex = enumValue->ImpliedValue;
            foundMin = true;
        }
    }

    return currentIndex;
}
