#include "SuperEnum.h"
#include <memory>

using namespace SuperEnumGenerator;
using namespace FatedQuestLibraries;

SuperEnum::SuperEnum()
{
}

bool SuperEnum::FromString(const std::string& superEnumFile)
{
    std::shared_ptr<XMLDocument> xml = std::make_shared<RapidXMLDocument>();
    if (!xml->Load(superEnumFile))
    {
        // Could not parse.
        return false;
    }

    std::shared_ptr<XMLNode> root = xml->GetRoot();
    for (std::shared_ptr<XMLNode> child = root->GetFirstChild(); child; child = child->GetAdjacentNode())
    {
        std::string name = StringHelpers::Trim(StringHelpers::ToLower(child->Name()));
        if (name == "namespace")
        {
            if (!ParseNamespace(child))
            {
                return false;
            }
        }
        else if (name == "enumcomment")
        {
            if (!ParseEnumComment(child))
            {
                return false;
            }
        }
        else if (name == "enumname")
        {
            if (!ParseEnumName(child))
            {
                return false;
            }
        }
    }


    return true;
}

std::string SuperEnum::ToString()
{
    std::string output = "";
    output += "#pragma once\n";
    output += "// +------------------------------+\n";
    output += "// Generated by SuperGenerator as an\n";
    output += "// SuperEnum. See Tools for details.\n";
    output += "// Date: " + PrintDateTime() + "\n";
    output += "// +------------------------------+\n";

    int indents = 0;
    if (m_namespace.Parsed)
    {
        output += "namespace " + m_namespace.Value + "\n";
        output += "{\n";
        ++indents;
    }

    output += PrintEnum(indents);

    if (m_namespace.Parsed)
    {
        --indents;
        output += "}\n";
    }
    return output;
}

bool SuperEnum::ParseNamespace(std::shared_ptr<XMLNode> namespaceNode)
{
    for (std::shared_ptr<XMLAttribute> attribute : namespaceNode->Attributes())
    {
        if (StringHelpers::ToLower(attribute->Name()) == "name")
        {
            std::string value = StringHelpers::Trim(attribute->Value());
            if (value != "")
            {
                m_namespace.Parsed = true;
                m_namespace.Value = value;
            }
        }
    }


    return m_namespace.Parsed;
}

bool SuperEnumGenerator::SuperEnum::ParseEnumComment(std::shared_ptr<XMLNode> enumNode)
{
    std::string comment = StringHelpers::Trim(enumNode->Inner());
    if (comment == "")
    {
        return false;
    }

    m_enumComment.Parsed = true;
    m_enumComment.Value = comment;

    return true;
}

bool SuperEnum::ParseEnumName(std::shared_ptr<XMLNode> enumNode)
{
    for (std::shared_ptr<XMLAttribute> attribute : enumNode->Attributes())
    {
        if (StringHelpers::ToLower(attribute->Name()) == "name")
        {
            std::string value = StringHelpers::Trim(attribute->Value());
            if (value != "")
            {
                m_enumName.Parsed = true;
                m_enumName.Value = value;
            }
        }
    }

    for (std::shared_ptr<XMLNode> child = enumNode->GetFirstChild(); child; child = child->GetAdjacentNode())
    {
        std::shared_ptr<EnumValueString> enumValue = std::make_shared<EnumValueString>();
        
        enumValue->Value = child->Name();
        enumValue->LowercaseValue = StringHelpers::ToLower(child->Name());
        enumValue->Comment = child->Inner();

        m_enumValues.push_back(enumValue);
    }

    return m_enumName.Parsed && m_enumValues.size() > 0;
}

std::string SuperEnum::PrintDateTime()
{
    std::time_t currentTime = std::time(nullptr);
    std::tm localTime;

    if (localtime_s(&localTime, &currentTime) != 0) {
        std::cerr << "Error getting local time!" << std::endl;
        return "";
    }

    std::stringstream outputStream;
    outputStream << (localTime.tm_year + 1900);
    outputStream << "/" << (localTime.tm_mon + 1);
    outputStream << "/" << localTime.tm_mday;
    outputStream << " " << localTime.tm_hour;
    outputStream << ":" << localTime.tm_min;
    outputStream << ":" << localTime.tm_sec;

    return outputStream.str();
}

std::string SuperEnum::PrintIndents(int number)
{
    std::string output = "";
    for (int i = 0; i < number; ++i)
    {
        output += "    ";
    }

    return output;
}

std::string SuperEnum::PrintEnum(int indents)
{
    std::string output;
    if (m_enumComment.Parsed)
    {
        output += PrintSingleComment(m_enumComment.Value, indents);
    }

    if (m_enumName.Parsed)
    {
        output += PrintIndents(indents) + "enum class " + m_enumName.Value + "\n";
        output += PrintIndents(indents) + "{\n";
        ++indents;
    }

    for (int i = 0; i < m_enumValues.size(); ++i)
    {
        const std::shared_ptr<EnumValueString>& enumValue = m_enumValues[i];
        std::string comments = PrintSingleComment(enumValue->Comment, indents);
        if (comments != "")
        {
            output += comments;
        }

        output += PrintIndents(indents) + enumValue->Value + ",\n";

        // Ensure there is a line space between each other than the very last.
        if (i + 1 < m_enumValues.size())
        {
            output += "\n";
        }
    }

    if (m_namespace.Parsed)
    {
        --indents;
        output += PrintIndents(indents) + "};\n";
    }

    return output;
}

std::string SuperEnumGenerator::SuperEnum::PrintSingleComment(const std::string& rawComment, int indents)
{
    std::string output = "";
    if (rawComment.empty())
    {
        return output;
    }

    output += PrintIndents(indents) + "/// <summary>\n";
    std::vector<std::string> lines = StringHelpers::Split(rawComment, "\n");
    for (const std::string line : lines)
    {
        std::string lineTrimmed = StringHelpers::Trim(line);
        if (lineTrimmed != "")
        {
            output += PrintIndents(indents) + "/// " + lineTrimmed + "\n";
        }
    }
    output += PrintIndents(indents) + "/// </summary>\n";

    return output;
}
