#include "SuperEnum.h"
#include <memory>

using namespace SuperEnumGenerator;
using namespace FatedQuestLibraries;

SuperEnum::SuperEnum()
{
}

bool SuperEnum::FromString(const std::string& superEnumFile)
{
    std::shared_ptr<XMLDocument> xml = std::make_shared<RapidXMLDocument>();
    if (!xml->Load(superEnumFile))
    {
        // Could not parse.
        return false;
    }

    std::shared_ptr<XMLNode> root = xml->GetRoot();
    for (std::shared_ptr<XMLNode> child = root->GetFirstChild(); child; child = child->GetAdjacentNode())
    {
        std::string name = StringHelpers::Trim(StringHelpers::ToLower(child->Name()));
        if (name == "header")
        {
            if (!ParseHeader(child))
            {
                return false;
            }
        }
        else if (name == "namespace")
        {
            if (!ParseNamespace(child))
            {
                return false;
            }
        }
        else if (name == "enumcomment")
        {
            if (!ParseEnumComment(child))
            {
                return false;
            }
        }
        else if (name == "enumname")
        {
            if (!ParseEnumName(child))
            {
                return false;
            }
        }
    }


    return true;
}

std::string SuperEnum::ToString()
{
    std::string output = "";
    int indents = 0;

    output += PrintHeader(indents);
    output += "// +------------------------------+\n";
    output += "// Generated by SuperGenerator as an\n";
    output += "// SuperEnum. See Tools for details.\n";
    output += "// Date: " + PrintDateTime() + "\n";
    output += "// +------------------------------+\n";

    if (m_namespace.Parsed)
    {
        output += "namespace " + m_namespace.Value + "\n";
        output += "{\n";
        ++indents;
    }

    output += PrintEnum(indents);

    output += PrintEnumHelper(indents);


    if (m_namespace.Parsed)
    {
        --indents;
        output += "}\n";
    }
    return output;
}

bool SuperEnum::ParseHeader(std::shared_ptr<XMLNode> headerNode)
{
    std::string header = StringHelpers::Trim(headerNode->Inner());
    if (header == "")
    {
        return false;
    }

    m_header.Parsed = true;
    m_header.Value = header;

    return true;
}

bool SuperEnum::ParseNamespace(std::shared_ptr<XMLNode> namespaceNode)
{
    for (std::shared_ptr<XMLAttribute> attribute : namespaceNode->Attributes())
    {
        if (StringHelpers::ToLower(attribute->Name()) == "name")
        {
            std::string value = StringHelpers::Trim(attribute->Value());
            if (value != "")
            {
                m_namespace.Parsed = true;
                m_namespace.Value = value;
            }
        }
    }


    return m_namespace.Parsed;
}

bool SuperEnum::ParseEnumComment(std::shared_ptr<XMLNode> enumNode)
{
    std::string comment = StringHelpers::Trim(enumNode->Inner());
    if (comment == "")
    {
        return false;
    }

    m_enumComment.Parsed = true;
    m_enumComment.Value = comment;

    return true;
}

bool SuperEnum::ParseEnumName(std::shared_ptr<XMLNode> enumNode)
{
    for (std::shared_ptr<XMLAttribute> attribute : enumNode->Attributes())
    {
        std::string name = StringHelpers::ToLower(attribute->Name());
        if (name == "name")
        {
            std::string value = StringHelpers::Trim(attribute->Value());
            if (value != "")
            {
                m_enumName.Parsed = true;
                m_enumName.Value = value;
            }
        }
    }

    for (std::shared_ptr<XMLNode> child = enumNode->GetFirstChild(); child; child = child->GetAdjacentNode())
    {
        std::shared_ptr<EnumValueString> enumValue = std::make_shared<EnumValueString>();
        
        enumValue->Value = child->Name();
        enumValue->LowercaseValue = StringHelpers::ToLower(child->Name());
        enumValue->Comment = child->Inner();

        bool parsedAttributes = true;
        for (std::shared_ptr<XMLAttribute> attribute : child->Attributes())
        {
            std::string name = StringHelpers::ToLower(attribute->Name());
            if (name == "value")
            {
                std::string value = StringHelpers::Trim(attribute->Value());
                if (value != "")
                {
                    int outValue = 0;
                    if (IntHelpers::TryParse(attribute->Value(), outValue))
                    {
                        enumValue->SetValue = outValue;
                        enumValue->ValueIsSet = true;
                    }
                    else
                    {
                        // Could not read number.
                        // TODO: Add Log for this.
                        parsedAttributes = false;
                        break;
                    }
                }
            }
            else if (name == "hidefromlists")
            {
                std::string value = StringHelpers::ToLower(StringHelpers::Trim(attribute->Value()));
                if (value != "")
                {
                    if (value == "true" || value == "t")
                    {
                        enumValue->HideFromLists = true;
                    }
                    else
                    {
                        enumValue->HideFromLists = false;
                    }
                }
            }
            else if (name == "isunknownvalue")
            {
                std::string value = StringHelpers::ToLower(StringHelpers::Trim(attribute->Value()));
                if (value != "")
                {
                    if (value == "true" || value == "t")
                    {
                        enumValue->IsUnknownValue = true;
                    }
                    else
                    {
                        enumValue->IsUnknownValue = false;
                    }
                }
            }
        }

        m_enumValues.push_back(enumValue);
    }

    SetUpImpliedEnumValues();

    return m_enumName.Parsed && m_enumValues.size() > 0;
}

bool SuperEnum::SetUpImpliedEnumValues()
{
    int currentIndex = 0;
    for (int i = 0; i < m_enumValues.size(); ++i)
    {
        if (m_enumValues[i]->ValueIsSet)
        {
            m_enumValues[i]->ImpliedValue = m_enumValues[i]->SetValue;
            currentIndex = m_enumValues[i]->SetValue + 1;
        }
        else
        {
            m_enumValues[i]->ImpliedValue = currentIndex++;
        }
    }

    return true;
}

std::string SuperEnum::PrintDateTime()
{
    std::time_t currentTime = std::time(nullptr);
    std::tm localTime;

    if (localtime_s(&localTime, &currentTime) != 0) {
        std::cerr << "Error getting local time!" << std::endl;
        return "";
    }

    std::stringstream outputStream;
    outputStream << (localTime.tm_year + 1900);
    outputStream << "/" << (localTime.tm_mon + 1);
    outputStream << "/" << localTime.tm_mday;
    outputStream << " " << localTime.tm_hour;
    outputStream << ":" << localTime.tm_min;
    outputStream << ":" << localTime.tm_sec;

    return outputStream.str();
}

std::string SuperEnum::PrintIndents(int number)
{
    std::string output = "";
    for (int i = 0; i < number; ++i)
    {
        output += "    ";
    }

    return output;
}

std::string SuperEnumGenerator::SuperEnum::PrintHeader(int indents)
{
    std::string output = "";
    if (!m_header.Parsed)
    {
        return output;
    }

    std::vector<std::string> lines = StringHelpers::Split(m_header.Value, "\n");
    for (const std::string line : lines)
    {
        std::string lineTrimmed = StringHelpers::Trim(line);
        if (lineTrimmed != "")
        {
            output += PrintIndents(indents) + lineTrimmed + "\n";
        }
    }
    output += PrintIndents(indents) + "\n";

    return output;
}

std::string SuperEnum::PrintEnum(int indents)
{
    std::string output;
    if (m_enumComment.Parsed)
    {
        output += PrintSingleComment(m_enumComment.Value, indents);
    }

    if (m_enumName.Parsed)
    {
        output += PrintIndents(indents) + "enum class " + m_enumName.Value + "\n";
        output += PrintIndents(indents) + "{\n";
        ++indents;
    }

    for (int i = 0; i < m_enumValues.size(); ++i)
    {
        const std::shared_ptr<EnumValueString>& enumValue = m_enumValues[i];
        std::string comments = PrintSingleComment(enumValue->Comment, indents);
        if (comments != "")
        {
            output += comments;
        }

        // Print the actual name within the enum class
        output += PrintIndents(indents) + enumValue->Value;
        if (enumValue->ValueIsSet)
        {
            output += " = " + std::to_string(enumValue->SetValue);
        }
        output += ",\n";

        // Ensure there is a line space between each other than the very last.
        if (i + 1 < m_enumValues.size())
        {
            output += "\n";
        }
    }

    if (m_namespace.Parsed)
    {
        --indents;
        output += PrintIndents(indents) + "};\n";
    }

    return output;
}

std::string SuperEnum::PrintEnumHelper(int indents)
{
    std::string output = "";
    if (!m_enumName.Parsed)
    {
        return std::string();
    }

    output += "\n";
    output += PrintSingleComment("Accompanies enums to provide extra functionality.", indents);
    output += PrintIndents(indents) + "class E" + m_enumName.Value + " : public Object\n";
    output += PrintIndents(indents) + "{\n";
    output += PrintIndents(indents) + "public:\n";

    ++indents;
    output += PrintIndents(indents) + "static " + m_enumName.Value + " Min() { return " + m_enumName.Value + "::" + GetMinEnumValue() + "; }\n";
    output += PrintIndents(indents) + "static " + m_enumName.Value + " Max() { return " + m_enumName.Value + "::" + GetMaxEnumValue() + "; }\n";
    output += PrintToArray(indents);
    output += PrintToVector(indents);
    output += PrintToString(indents);
    output += PrintFromString(indents);
    --indents;

    output += PrintIndents(indents) + "};\n";

    return output;
}

std::string SuperEnum::PrintToArray(int indents)
{
    if (!m_enumName.Parsed)
    {
        return std::string();
    }

    std::string output = "";

    output += "\n";
    output += PrintIndents(indents) + "static " + m_enumName.Value + "* ToArray()\n";
    output += PrintIndents(indents) + "{\n";
        ++indents;
        output += PrintIndents(indents) + "static " + m_enumName.Value + " returnArray[] =\n";
        output += PrintIndents(indents) + "{\n";
            ++indents;
            for (const std::shared_ptr<EnumValueString>& enumValue : m_enumValues)
            {
                if (enumValue->HideFromLists)
                {
                    continue;
                }

                output += PrintIndents(indents) + m_enumName.Value + "::" + enumValue->Value + ",\n";

            }
            --indents;
            output += PrintIndents(indents) + "};\n";
            output += PrintIndents(indents) + "\n";
            output += PrintIndents(indents) + "return returnArray;\n";
        --indents;
    output += PrintIndents(indents) + "}\n";
    return output;
}

std::string SuperEnum::PrintToVector(int indents)
{
    if (!m_enumName.Parsed)
    {
        return std::string();
    }

    std::string output = "";

    output += "\n";
    output += PrintIndents(indents) + "static std::vector<" + m_enumName.Value + "> ToVector()\n";
    output += PrintIndents(indents) + "{\n";
    ++indents;
        output += PrintIndents(indents) + "static std::vector<" + m_enumName.Value + "> returnVector =\n";
        output += PrintIndents(indents) + "{\n";
        ++indents;
            for (const std::shared_ptr<EnumValueString>& enumValue : m_enumValues)
            {
                if (enumValue->HideFromLists)
                {
                    continue;
                }

                output += PrintIndents(indents) + m_enumName.Value + "::" + enumValue->Value + ",\n";

            }
        --indents;
        output += PrintIndents(indents) + "};\n";
        output += PrintIndents(indents) + "\n";
        output += PrintIndents(indents) + "return returnVector;\n";
    --indents;
    output += PrintIndents(indents) + "}\n";
    return output;
}

std::string SuperEnum::PrintToString(int indents)
{
    if (!m_enumName.Parsed)
    {
        return std::string();
    }

    std::string output = "";

    output += "\n";
    output += PrintIndents(indents) + "static std::string ToString(" + m_enumName.Value + " value)\n";
    output += PrintIndents(indents) + "{\n";
    ++indents;
        output += PrintIndents(indents) + "switch (value)\n";
        output += PrintIndents(indents) + "{\n";
        ++indents;
            for (const std::shared_ptr<EnumValueString>& enumValue : m_enumValues)
            {
                output += PrintIndents(indents) + "case " + m_enumName.Value + "::" + enumValue->Value;
                output += ": return \"" + enumValue->Value + "\";\n";

            }
        --indents;
        output += PrintIndents(indents) + "}\n";
        output += PrintIndents(indents) + "\n";
        output += PrintIndents(indents) + "return \""+ GetUnknownValue() + "\";\n";
    --indents;
    output += PrintIndents(indents) + "}\n";
    return output;
}

std::string SuperEnum::PrintFromString(int indents)
{
    if (!m_enumName.Parsed)
    {
        return std::string();
    }

    std::string output = "";

    output += "\n";
    output += PrintIndents(indents) + "static " + m_enumName.Value + " FromString(std::string value, bool checkCase = true)\n";
    output += PrintIndents(indents) + "{\n";
    ++indents;
        output += PrintIndents(indents) + "if (checkCase)\n";
        output += PrintIndents(indents) + "{\n";
        ++indents;
        for (const std::shared_ptr<EnumValueString>& enumValue : m_enumValues)
        {
            output += PrintIndents(indents) + "if (value == \"" + enumValue->Value + "\") return " + m_enumName.Value + "::" + enumValue->Value + ";\n";
        }
        --indents;
        output += PrintIndents(indents) + "}\n";
        output += PrintIndents(indents) + "else\n";
        output += PrintIndents(indents) + "{\n";
        ++indents;
        output += PrintIndents(indents) + "std::string valueLower = StringHelpers::ToLower(value); \n";
        for (const std::shared_ptr<EnumValueString>& enumValue : m_enumValues)
        {
            
            output += PrintIndents(indents) + "if (valueLower == \"" + enumValue->LowercaseValue + "\") return " + m_enumName.Value + "::" + enumValue->Value + ";\n";
        }
        --indents;
        output += PrintIndents(indents) + "}\n";
        output += PrintIndents(indents) + "\n";
        output += PrintIndents(indents) + "return \"" + GetUnknownValue() + "\";\n";
    --indents;
    output += PrintIndents(indents) + "}\n";
    return output;
}

std::string SuperEnum::GetMinEnumValue()
{
    bool foundMin = false;
    int currentIndex = 0;
    std::string min = "";
    for (const std::shared_ptr<EnumValueString>& enumValue : m_enumValues)
    {
        if (enumValue->HideFromLists)
        {
            // Min and Max count as lists.
            continue;
        }

        if (!foundMin || enumValue->ImpliedValue < currentIndex)
        {
            currentIndex = enumValue->ImpliedValue;
            min = enumValue->Value;
            foundMin = true;
        }
    }

    return min;
}

std::string SuperEnum::GetMaxEnumValue()
{
    bool foundMin = false;
    int currentIndex = 0;
    std::string max = "";
    for (const std::shared_ptr<EnumValueString>& enumValue : m_enumValues)
    {
        if (enumValue->HideFromLists)
        {
            // Min and Max count as lists.
            continue;
        }

        if (!foundMin || enumValue->ImpliedValue > currentIndex)
        {
            currentIndex = enumValue->ImpliedValue;
            max = enumValue->Value;
            foundMin = true;
        }
    }

    return max;
}

std::string SuperEnum::GetUnknownValue()
{
    bool foundValue = false;
    std::string unknown = "";
    for (const std::shared_ptr<EnumValueString>& enumValue : m_enumValues)
    {
        if (!foundValue)
        {
            unknown = enumValue->Value;
            foundValue = true;
        }

        if (enumValue->IsUnknownValue)
        {
            unknown = enumValue->Value;
            break;
        }
    }

    return unknown;
}

std::string SuperEnum::PrintSingleComment(const std::string& rawComment, int indents)
{
    std::string output = "";
    if (rawComment.empty())
    {
        return output;
    }

    output += PrintIndents(indents) + "/// <summary>\n";
    std::vector<std::string> lines = StringHelpers::Split(rawComment, "\n");
    for (const std::string line : lines)
    {
        std::string lineTrimmed = StringHelpers::Trim(line);
        if (lineTrimmed != "")
        {
            output += PrintIndents(indents) + "/// " + lineTrimmed + "\n";
        }
    }
    output += PrintIndents(indents) + "/// </summary>\n";

    return output;
}
